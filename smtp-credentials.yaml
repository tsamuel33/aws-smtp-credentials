AWSTemplateFormatVersion: 2010-09-09
Description: >-
  This template creates a custom SMTP resource that stores the SMTP
  credentials in Parameter Store under the names "smtp-username" and
  "smtp-password".

Parameters:
  IamAccessKeyVersion:
    Type: Number
    Default: 1
    Description: Version number of the AWS access keys. Increment this number to rotate the keys.
    MinValue: 1
  KmsKeyArn:
    Type: String
    Description: (Optional) ARN of the KMS key used to encrypt the SMTP credentials in Parameter Store
    Default: ""
    AllowedPattern: '^(arn:aws:kms:(us|af|ap|ca|eu|il|mx|me|sa)-(east|west|south|north|southeast|northeast|central)-[1-7]:\d{12}:key\/[a-z0-9]{8}(-[a-z0-9]{4}){3}-[a-z0-9]{12}$)?'
    ConstraintDescription: This value must be a valid ACM certificate ARN format, or left blank
  Username:
    Type: String
    Description: Desired name of the IAM user
    Default: SMTPUser
  LambdaLogRetentionTime:
    Type: Number
    Description: The length of time in days to retain the Sectigo Lambda function execution logs
    Default: 14
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
      - 120
      - 150
      - 180
      - 365

Conditions:
  UseCustomKMSKey: !Not [!Equals [!Ref KmsKeyArn, ""]]

Resources:
  SmtpUserGroup:
    Type: AWS::IAM::Group
    Properties:
      GroupName: !Sub ${Username}Group
  SmtpUser:
    Type: AWS::IAM::User
    Properties:
      UserName: !Ref Username
      Groups:
        - !Ref SmtpUserGroup
  SmtpUserPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: !Sub ${Username}Policy
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - ses:SendEmail
              - ses:SendRawEmail
            Resource: '*'
      Groups:
        - !Ref SmtpUserGroup
  SmtpUserAccessKey:
    Type: AWS::IAM::AccessKey
    Properties:
      Serial: !Ref IamAccessKeyVersion
      Status: Active
      UserName: !Ref SmtpUser

  SmtpPassword:
    Type: Custom::SmtpPassword
    DependsOn: SmtpLambdaLogGroup
    Properties:
      ServiceToken: !GetAtt SMTPCredentialsLambdaFunction.Arn
      Key: !GetAtt SmtpUserAccessKey.SecretAccessKey
      ParameterType: password
      UserName: !Ref Username

  SmtpUsername:
    Type: Custom::SmtpUsername
    DependsOn: SmtpLambdaLogGroup
    Properties:
      ServiceToken: !GetAtt SMTPCredentialsLambdaFunction.Arn
      Key: !Ref SmtpUserAccessKey
      ParameterType: username
      UserName: !Ref Username

  SMTPLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Description: Role assumed by Lambda to generate SMTP credentials
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: InlineSMTPLambdaExecutionRolePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
                - Fn::If:
                  - UseCustomKMSKey
                  - Effect: Allow
                    Action:
                      - kms:Decrypt
                      - kms:DescribeKey
                      - kms:CreateGrant
                      - kms:Encrypt
                    Resource:
                      - !Ref KmsKeyArn
                  - !Ref AWS::NoValue
                - Effect: Allow
                  Action:
                    - ssm:PutParameter
                    - ssm:DeleteParameter
                  Resource:
                    - !Sub "arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/*-smtp-username"
                    - !Sub "arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/*-smtp-password"

  SmtpLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      LogGroupName: !Sub /aws/lambda/${SMTPCredentialsLambdaFunction}
      RetentionInDays: !Ref LambdaLogRetentionTime


# The following function is based on data from https://docs.aws.amazon.com/ses/latest/dg/smtp-credentials.html
  SMTPCredentialsLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Description: Generates SMTP credentials and stores in Parameter Store
      Handler: index.lambda_handler
      MemorySize: 128
      Environment:
        Variables:
          KMS_KEY_ARN: !Ref KmsKeyArn
      Role: !GetAtt SMTPLambdaExecutionRole.Arn
      Runtime: python3.13
      Timeout: 30
      Code:
        ZipFile: !Sub |
          import hmac
          import hashlib
          import base64
          import boto3
          from botocore.exceptions import ClientError
          import cfnresponse
          import logging
          import os
          import logging
          from sys import exit

          # Configure logging
          logging.basicConfig(level=logging.DEBUG)
          log = logging.getLogger(__name__)

          # Constants
          REGION = os.environ['AWS_REGION']
          SMTP_REGIONS = [
              "us-east-2",  # US East (Ohio)
              "us-east-1",  # US East (N. Virginia)
              "us-west-2",  # US West (Oregon)
              "ap-south-1",  # Asia Pacific (Mumbai)
              "ap-northeast-2",  # Asia Pacific (Seoul)
              "ap-southeast-1",  # Asia Pacific (Singapore)
              "ap-southeast-2",  # Asia Pacific (Sydney)
              "ap-northeast-1",  # Asia Pacific (Tokyo)
              "ca-central-1",  # Canada (Central)
              "eu-central-1",  # Europe (Frankfurt)
              "eu-west-1",  # Europe (Ireland)
              "eu-west-2",  # Europe (London)
              "eu-south-1",  # Europe (Milan)
              "eu-north-1",  # Europe (Stockholm)
              "sa-east-1",  # South America (Sao Paulo)
              "us-gov-west-1",  # AWS GovCloud (US)
              "us-gov-east-1",  # AWS GovCloud (US)
          ]
          CUSTOM_KMS_KEY = not os.environ['KMS_KEY_ARN'] == ""

          # Boto3 Clients
          ssm = boto3.client('ssm', region_name=REGION)

          # Boto3 Decorators
          """
          These Python decorators signal the success or failure of Lambda-backed CloudFormation 
          custom resources. To use these resources:

          1. Since the signal requires data that will be provided by the inputs to the lambda
          handler (i.e., 'event' and 'context'), the long form of a decorator needs to be used.
          For example, if you have the following function defined in your code:

          def sample_function(params):
              ....

          Call the decorator by stating something like:
          'outcome = assess_cfn_status(event, context, data, id, False)(sample_function)(params)'

          3. The last parameter (final_step) of the assess_cfn_status function/decorator indicates
          if this is the final step of the custom resource logic. If set to "True", the decorator will
          send a success signal to CloudFormation if the result is successful. Please note that the
          function will exit without returning the result, so set it to "False" and call
          cfnresponse.send outside of the function if you need to use the result before signaling (i.e.,
          adding the output to the resource output attributes)
          """
          def send_cfn_signal(event, context, data, id, final_step=False):
              def inner(func):
                  def wrapper(*args, **kwargs):
                      error = None
                      outcome = func(*args, **kwargs)
                      err_msg = "Custom resource execution failed. See the further details in CloudWatch Log Stream: {}.".format(context.log_stream_name)
                      if isinstance(outcome, dict):
                          if "CFN_Response_Status" in outcome:
                              if "Error_Message" in outcome:
                                  err_msg = outcome["Error_Message"]
                              elif "Error" in outcome:
                                  error = outcome["Error"]
                                  log.error(err_msg)
                              cfnresponse.send(event, context, cfnresponse.FAILED, data, id, reason=err_msg)
                              if error is not None:
                                  raise error
                              else:
                                  exit()
                          else:
                              return outcome
                      if final_step:
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, data, id)
                          exit()
                      else:
                          return outcome
                  return wrapper
              return inner

          def boto3_err_msg(func):
              def wrapper(*args, **kwargs):
                  try:
                      response = func(*args, **kwargs)
                      return response
                  except ClientError as err:
                      message = err.response['Error']['Message']
                      log.error(message)
                      payload = {
                          "CFN_Response_Status": cfnresponse.FAILED,
                          "Error_Message": message
                      }
                      return payload
                  except Exception as err:
                      payload = {
                          "CFN_Response_Status": cfnresponse.FAILED,
                          "Error": err
                      }
                      log.error("Encountered error that was not a boto3 ClientError.")
                      return payload
              return wrapper

          def assess_cfn_status(event, context, data, id, final_step=False):
              def inner(boto_func):
                  def wrapper(*args, **kwargs):
                      new_func = send_cfn_signal(event, context, data, id, final_step)(boto3_err_msg(boto_func))
                      result = new_func(*args, **kwargs)
                      return result
                  return wrapper
              return inner

          # These values are required to calculate the signature. Do not change them.
          DATE = "11111111"
          SERVICE = "ses"
          MESSAGE = "SendRawEmail"
          TERMINAL = "aws4_request"
          VERSION = 0x04

          def sign(key, msg):
              return hmac.new(key, msg.encode('utf-8'), hashlib.sha256).digest()

          def calculate_key(secret_access_key, region):
              if region not in SMTP_REGIONS:
                  raise ValueError(f"The {region} Region doesn't have an SMTP endpoint.")

              signature = sign(("AWS4" + secret_access_key).encode('utf-8'), DATE)
              signature = sign(signature, region)
              signature = sign(signature, SERVICE)
              signature = sign(signature, TERMINAL)
              signature = sign(signature, MESSAGE)
              signature_and_version = bytes([VERSION]) + signature
              smtp_password = base64.b64encode(signature_and_version)
              return smtp_password.decode('utf-8')

          def put_parameter(username, value, type):
                  if CUSTOM_KMS_KEY:
                      ssm.put_parameter(
                              Name=f"{username}-smtp-{type}",
                              Description=f"SMTP {type} for email communications",
                              Value=value,
                              Type='SecureString',
                              KeyId=os.environ['KMS_KEY_ARN'],
                              Overwrite=True,
                              Tier='Standard'
                          )
                  else:
                      ssm.put_parameter(
                              Name=f"{username}-smtp-{type}",
                              Description=f"SMTP {type} for email communications",
                              Value=value,
                              Type='SecureString',
                              Overwrite=True,
                              Tier='Standard'
                          )
                  return None

          def delete_smtp_credentials(username, type):
              ssm.delete_parameter(Name=f"{username}-smtp-{type}")
              return None


          def lambda_handler(event, context):
              parameter_type = event['ResourceProperties']['ParameterType']
              username = event['ResourceProperties']['UserName']
              key = event['ResourceProperties']['Key']
              parameter_arn = "arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/" + f"{username}-smtp-{parameter_type}"
              cfn_data ={}

              if event['RequestType'] == 'Create':
                  if parameter_type == 'username':
                      assess_cfn_status(event, context, cfn_data, parameter_arn, True)(put_parameter)(username, key, parameter_type)
                  elif parameter_type == 'password':
                      pwd = assess_cfn_status(event, context, cfn_data, parameter_arn, False)(calculate_key)(key, REGION)
                      assess_cfn_status(event, context, cfn_data, parameter_arn, True)(put_parameter)(username, pwd, parameter_type)
              elif event['RequestType'] == 'Update':
                  name_change = False
                  if "OldResourceProperties" in event:
                      old_username = event['OldResourceProperties']['UserName']
                      if username != old_username:
                          name_change = True
                  final = not name_change
                  if parameter_type == 'username':
                      assess_cfn_status(event, context, cfn_data, parameter_arn, final)(put_parameter)(username, key, parameter_type)
                  elif parameter_type == 'password':
                      pwd = assess_cfn_status(event, context, cfn_data, parameter_arn, False)(calculate_key)(key, REGION)
                      assess_cfn_status(event, context, cfn_data, parameter_arn, final)(put_parameter)(username, pwd, parameter_type)
                  if name_change:
                      assess_cfn_status(event, context, cfn_data, parameter_arn, name_change)(delete_smtp_credentials)(old_username, parameter_type)
              elif event['RequestType'] == 'Delete':
                  assess_cfn_status(event, context, cfn_data, parameter_arn, True)(delete_smtp_credentials)(username, parameter_type)